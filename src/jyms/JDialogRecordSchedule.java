/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package jyms;

import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Vector;
import javax.swing.JTable;
import javax.swing.SwingWorker;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumnModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import jyms.tools.TableUtil.JTableCheckBoxModel;
import jyms.data.DeviceResourceBean;
import jyms.data.TxtLogger;
import jyms.tools.TreeUtil;
import jyms.ui.PanelUI_MatteBorder;
import jyms.ui.ScrollBarUI_White;
import jyms.ui.ScrollPaneUI_White;
import jyms.ui.SplitPaneUI_White;
import jyms.ui.TableHeaderUI_White;
import jyms.ui.TableUI_White;

/**
 *
 * @author John
 */
public class JDialogRecordSchedule extends javax.swing.JDialog {
    
    private final String sFileName = this.getClass().getName() + ".java";
    private DefaultMutableTreeNode m_RootDevice;//通道树根节点
    //获取DeviceResourceBean（设备资源表中的“设备序列号”、“节点名”、“设备资源分类”、“接入设备的序列号”）-0
    //对应的“设备别名-1”、“IP地址-2”等参数，及对应的的接入设备的“设备别名-3，设备资源分类名称-4（代码表中代码名称），加上录像通道状态-5
    private ArrayList listRecordChannelPara = new ArrayList();
    private JTableCheckBoxModel  RecordChannelTableModel;
    private String[] tableTitle = new String[]{"设置","录像通道","设备名","序列号"};
    private HashMap<String,NativeLong> bufferUserIDs = new HashMap<>();
    
    private String sAnotherName = "";//存储当前的设备别名
    private String sSerialNO = "";//存储当前的设备别序列号
    
    private RefreshRecordChannelParasWorker refreshWorker;//并发进程，刷新设备录像通道状态
    private boolean bDeviceRefreshing = false;//是否正在刷新设备录像通道状态

    /**
     * Creates new form JDialogRecordSchedule
     * @param parent
     * @param modal
     */
    public JDialogRecordSchedule(java.awt.Frame parent, boolean modal) {
        
        super(parent, modal);
        initComponents();
        modifyLocales();
        initialDialogParas();
    }
    
    /**
	 * 函数:      initialDialogParas
         * 函数描述:  初始化窗体的各种参数
    */
    private void initialDialogParas(){
        jTreeDevice.setModel(this.initialDeviceTreeModel());
        CommonParas.CreateDeviceTree(jTreeDevice, m_RootDevice, "", CommonParas.DVRType.DVRTYPE_ENCODINGDVR_NVR_CODE, sFileName);//监控设备
        jSplitPaneRecordChannel.setDividerLocation(140);
        RecordChannelTableModel = this.initialRecordChannelTableModel();
        
        jTableRecordChannel.setModel(RecordChannelTableModel);
        jTableRecordChannel.setRowHeight(30);
        setTableColWidth();
    
        jPanelContainer.setUI(new PanelUI_MatteBorder());
        jSplitPaneRecordChannel.setUI(new SplitPaneUI_White());
        
        
        jTableRecordChannel.getTableHeader().setUI(new TableHeaderUI_White());
        jTableRecordChannel.setUI(new TableUI_White());
        
        jScrollPaneRecord.setUI(new ScrollPaneUI_White());
        jScrollPaneRecord.getVerticalScrollBar().setUI(new ScrollBarUI_White());
        jScrollPaneRecord.getHorizontalScrollBar().setUI(new ScrollBarUI_White());
        
        
        jScrollPaneDevice.setUI(new ScrollPaneUI_White());
        jScrollPaneDevice.getVerticalScrollBar().setUI(new ScrollBarUI_White());
        jScrollPaneDevice.getHorizontalScrollBar().setUI(new ScrollBarUI_White());
 

        CommonParas.setJButtonUnDecorated(jButtonExit);
        
        jTreeDevice.setCellRenderer(new TreeUtil.CustomNodeTreeCellRenderer());
        
        //刷新设备录像通道状态
        refreshWorker = new RefreshRecordChannelParasWorker();
        refreshWorker.execute();

    }
    
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelFirst = new javax.swing.JPanel();
        jLabelTitle = new javax.swing.JLabel();
        jButtonExit = new javax.swing.JButton();
        jPanelContainer = new javax.swing.JPanel();
        jSplitPaneRecordChannel = new javax.swing.JSplitPane();
        jScrollPaneDevice = new javax.swing.JScrollPane();
        jTreeDevice = new javax.swing.JTree();
        jScrollPaneRecord = new javax.swing.JScrollPane();
        jTableRecordChannel = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("录像存储快速设置");
        setUndecorated(true);

        jLabelTitle.setFont(new java.awt.Font("微软雅黑", 1, 18)); // NOI18N
        jLabelTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelTitle.setText("录像存储快速设置");

        jButtonExit.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jyms/image/close.png"))); // NOI18N
        jButtonExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonExitActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelFirstLayout = new javax.swing.GroupLayout(jPanelFirst);
        jPanelFirst.setLayout(jPanelFirstLayout);
        jPanelFirstLayout.setHorizontalGroup(
            jPanelFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelFirstLayout.createSequentialGroup()
                .addComponent(jLabelTitle, javax.swing.GroupLayout.DEFAULT_SIZE, 797, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButtonExit, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        jPanelFirstLayout.setVerticalGroup(
            jPanelFirstLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelFirstLayout.createSequentialGroup()
                .addComponent(jButtonExit, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(21, Short.MAX_VALUE))
            .addComponent(jLabelTitle, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        getContentPane().add(jPanelFirst, java.awt.BorderLayout.PAGE_START);

        jTreeDevice.setFont(new java.awt.Font("微软雅黑", 0, 16)); // NOI18N
        jTreeDevice.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                jTreeDeviceValueChanged(evt);
            }
        });
        jScrollPaneDevice.setViewportView(jTreeDevice);

        jSplitPaneRecordChannel.setLeftComponent(jScrollPaneDevice);

        jTableRecordChannel.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jTableRecordChannel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTableRecordChannelMouseClicked(evt);
            }
        });
        jScrollPaneRecord.setViewportView(jTableRecordChannel);

        jSplitPaneRecordChannel.setRightComponent(jScrollPaneRecord);

        javax.swing.GroupLayout jPanelContainerLayout = new javax.swing.GroupLayout(jPanelContainer);
        jPanelContainer.setLayout(jPanelContainerLayout);
        jPanelContainerLayout.setHorizontalGroup(
            jPanelContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 826, Short.MAX_VALUE)
            .addGroup(jPanelContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jSplitPaneRecordChannel, javax.swing.GroupLayout.DEFAULT_SIZE, 826, Short.MAX_VALUE))
        );
        jPanelContainerLayout.setVerticalGroup(
            jPanelContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 540, Short.MAX_VALUE)
            .addGroup(jPanelContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jSplitPaneRecordChannel, javax.swing.GroupLayout.DEFAULT_SIZE, 540, Short.MAX_VALUE))
        );

        getContentPane().add(jPanelContainer, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jTreeDeviceValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_jTreeDeviceValueChanged
        // TODO add your handling code here:
        try {
            DefaultMutableTreeNode selectionNode = (DefaultMutableTreeNode) jTreeDevice.getLastSelectedPathComponent();
            String nodeName = selectionNode.toString();
            // 判断是否为树叶节点，若是则读取设备通道录像参数，若不是则不做任何事。
            if (selectionNode == null) return;
            if (!selectionNode.isLeaf()) {
                nodeName = "";
            }
            refreshTableRecordChannel(nodeName);//刷新录像通道信息
            
        }catch (Exception e){
            TxtLogger.append(this.sFileName, "jTreeDeviceValueChanged()","系统在读取设备报警参数过程中，出现错误"
                             + "\r\n                       Exception:" + e.toString());
        }
    }//GEN-LAST:event_jTreeDeviceValueChanged

    private void jButtonExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonExitActionPerformed
        // TODO add your handling code here:
        if (refreshWorker != null)   refreshWorker.cancel(true);
        this.dispose();
    }//GEN-LAST:event_jButtonExitActionPerformed
    //原先使用MouseReleased事件，得到的值还是原来的值。
    //如果在设置录像通道状态失败时，需要将状态值重新恢复到原来值，结果即使恢复到原来值后，还是会继续执行点击事件，将该状态继续设置为新值
    //所以最后还是改用MouseClicked事件。
    private void jTableRecordChannelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTableRecordChannelMouseClicked
        // TODO add your handling code here:
        try{
            this.setCursor(new Cursor(Cursor.WAIT_CURSOR));
            int Row = jTableRecordChannel.getSelectedRow();
            int Row_Model= jTableRecordChannel.convertRowIndexToModel(Row);//将视图中的行索引转化为数据模型中的行索引
            if (Row < 0 ) return;
            if (jTableRecordChannel.getSelectedColumn() == 0){
                modifyRecordParas(Row_Model, true);
            }else{
                //双击
                if (evt.getClickCount() == 2) {
                    modifyRecordParas(Row_Model, false);
                }
            }
        }catch(Exception e){
            TxtLogger.append(this.sFileName, "jTableRecordChannelMouseClicked()","系统在设置录像通道过程中，出现错误" + 
                            "\r\n                       Exception:" + e.toString());   
        }
        this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }//GEN-LAST:event_jTableRecordChannelMouseClicked
    
    
    /**
        * 函数:      modifyRecordParas
        * 函数描述:  修改录像通道是否录像的状态
        * @param Row_Model      在JTableModel中的行号
        * @param DirectModify   是否直接点击CheckBox进行修改。false是双击其他栏进行修改
    */
    private void modifyRecordParas(int Row_Model, boolean DirectModify){
        try{
            boolean CurrentIfRecord = (boolean)RecordChannelTableModel.getValueAt(Row_Model,0);
            boolean NewIfRecord = !CurrentIfRecord;//双击事件，则新的值应该和原来的值相反
            if (DirectModify) NewIfRecord = CurrentIfRecord;//点击CheckBox，则新的值就是现在的值。

            ArrayList NewList = (ArrayList)listRecordChannelPara.get(Row_Model);//

            
            

            String AnotherName = (String)NewList.get(1);
            //根据设备名称得到UserID
            NativeLong UserID = CommonParas.getUserID(AnotherName, sFileName);


            //根据节点得到通道号，得到设备名称
            DeviceResourceBean NewResourceBean = (DeviceResourceBean)NewList.get(0);
            String SerialNo = NewResourceBean.getSerialno();
            String ChannelNode = NewResourceBean.getNodename();
            int Channel = CommonParas.getChannel(NewResourceBean.getNodename());

            HCNetSDK.NET_DVR_RECORD_V30 m_struRemoteRecCfg = (HCNetSDK.NET_DVR_RECORD_V30)NewList.get(5);
            if (m_struRemoteRecCfg == null) {
                //读取设备通道录像参数
                boolean getDVRConfigSuc = getStruRemoteRecCfg( m_struRemoteRecCfg,  UserID,  Channel);
                if (!getDVRConfigSuc) {
                    //写错误日志：操作时间、设备别名、描述信息、设备序列号、分组名、节点名、接入设备序列号、接入通道、设备类型、被操作对象类型、调用的文件名
                    CommonParas.SystemWriteErrorLog("", sAnotherName, sRecordParaSetup, SerialNo, "",ChannelNode, NewResourceBean.getsSerialnoJoin(),"",
                                                CommonParas.DVRType.DVRTYPE_ENCODINGDVR_CODE , CommonParas.DVRResourceType.RESTYPE_ENCODINGDVR_CHANNEL_CODE,sFileName);// "设置录像参数"
                    CommonParas.showErrorMessage( sRecordParaSetup_Fail, sAnotherName, sFileName); //"设置录像参数失败"
                    RecordChannelTableModel.setValueAt(!NewIfRecord, Row_Model, 0);
                    RecordChannelTableModel.fireTableDataChanged();
                    return;
                }
            }
            
            if (NewIfRecord) m_struRemoteRecCfg.dwRecord = 1;//如果最新值为选中，那么为录像状态
            else  m_struRemoteRecCfg.dwRecord = 0;//如果最新值为选中，那么为未录像状态
            
            boolean setDVRConfigSuc = false;
            m_struRemoteRecCfg.write();
            Pointer lpPicConfig = m_struRemoteRecCfg.getPointer();
            setDVRConfigSuc = CommonParas.hCNetSDK.NET_DVR_SetDVRConfig(UserID, HCNetSDK.NET_DVR_SET_RECORDCFG_V30,
                    new NativeLong(Channel), lpPicConfig, m_struRemoteRecCfg.size());
            m_struRemoteRecCfg.read();
            if (setDVRConfigSuc){
                //修改数据库中的数据
                boolean bReturn = DeviceResourceBean.setupRecordSchedule(SerialNo, ChannelNode, NewIfRecord, sFileName);
                if (!bReturn) TxtLogger.append(this.sFileName, "saveRecordSchedule()","修改设备资源表的是否已实现存储计划标志ifRecordSchedule时，出现错误");

                RecordChannelTableModel.setValueAt(NewIfRecord, Row_Model, 0);

                //写日志：操作时间、日志类型、描述信息、设备序列号、分组名、节点名、接入设备序列号、接入通道、设备类型、被操作对象类型、调用的文件名
                //为以后的兼容做准备，所以用了DVRTYPE_ENCODINGDVR_CODE（编码设备/门口机），而不是DVRTYPE_ENCODINGDVR_NVR_CODE（编码设备/门口机-NVR录像机）
                CommonParas.SystemWriteLog("", CommonParas.LogType.LOG_OPER_CODE, sRecordParaSetup, SerialNo, "", ChannelNode, NewResourceBean.getsSerialnoJoin(),"",
                                        CommonParas.DVRType.DVRTYPE_ENCODINGDVR_CODE, CommonParas.DVRResourceType.RESTYPE_ENCODINGDVR_CHANNEL_CODE, sFileName);// "设置录像参数"
                CommonParas.showMessage(NewIfRecord?sRecordParaSetupSucc:sRecordParaSetupSuccNot, sFileName);

            }else{

                RecordChannelTableModel.setValueAt(!NewIfRecord, Row_Model, 0);

                //写错误日志：操作时间、设备别名、描述信息、设备序列号、分组名、节点名、接入设备序列号、接入通道、设备类型、被操作对象类型、调用的文件名
                CommonParas.SystemWriteErrorLog("", sAnotherName, sRecordParaSetup_Fail , SerialNo, "",ChannelNode, NewResourceBean.getsSerialnoJoin(),"",
                                            CommonParas.DVRType.DVRTYPE_ENCODINGDVR_CODE , CommonParas.DVRResourceType.RESTYPE_ENCODINGDVR_CHANNEL_CODE,sFileName); //"设置录像参数失败"
                CommonParas.showErrorMessage( sRecordParaSetup_Fail , sAnotherName, sFileName);//"设置录像参数失败"
            }
            RecordChannelTableModel.fireTableDataChanged();
        }catch(Exception e){
            TxtLogger.append(this.sFileName, "modifyRecordParas()","系统在修改录像通道是否录像的状态过程中，出现错误" + 
                            "\r\n                       Exception:" + e.toString());   
        }
    }

    
    /**
        *函数:      initialDeviceTreeModel
        *函数描述:  初始化设备树
        * @return DefaultTreeModel
    */
    private DefaultTreeModel initialDeviceTreeModel()
    {
        m_RootDevice = new DefaultMutableTreeNode(sDevice);// "设备"
        DefaultTreeModel myDefaultTreeModel = new DefaultTreeModel(m_RootDevice);//使用根节点创建模型
        return myDefaultTreeModel;
    }
 
    /**
	 * 函数:      initialRecordChannelTableModel
         * 函数描述:  初始化设备录像通道列表jTableRecordChannel
         * @return JTableButtonModel
    */
    private JTableCheckBoxModel initialRecordChannelTableModel()
    {
//        String tabeTile[];
//        
//        tabeTile = new String[] {"设置","录像通道","设备名","序列号"};
        JTableCheckBoxModel  TableModel =new JTableCheckBoxModel(tableTitle);
        return TableModel;
    }
    /**
        *函数:      fillIntoTableRecordChannel
        *函数描述:  将录像通道的相关数据输出到表格中
    */
    private void fillIntoTableRecordChannel(String AnotherName){
        try {

            Vector v = RecordChannelTableModel.getDataVector();
            if (v != null) v.clear();
            for (int i=0;i<listRecordChannelPara.size();i++){
                ArrayList NewList = (ArrayList)listRecordChannelPara.get(i);//
                //获取DeviceResourceBean（设备资源表中的“设备序列号”、“节点名”、“设备资源分类”、“接入设备的序列号”）-0
                //对应的“设备别名-1”、“IP地址-2”等参数，及对应的的接入设备的“设备别名-3 、设备资源分类名称-4（代码表中代码名称），加上录像通道状态-5
                DeviceResourceBean deviceResourceBean = (DeviceResourceBean)NewList.get(0);

                //“设备序列号”,“节点名”,“设备资源分类”
                //"设置","录像通道","设备名","序列号"
                String AnotherName2 = (String)NewList.get(1);
                String AnotherNameJoin = (String)NewList.get(3);
                //AnotherName==""说明点击在根节点上；AnotherName != ""时只显示该设备的录像通道
                if (AnotherName.equals("") || AnotherName2.equals(AnotherName)){
                        Vector newRow = new Vector();

                        HCNetSDK.NET_DVR_RECORD_V30 m_struRemoteRecCfg = (HCNetSDK.NET_DVR_RECORD_V30)NewList.get(5);
                        if (m_struRemoteRecCfg == null) newRow.add(false);
                        else newRow.add(m_struRemoteRecCfg.dwRecord == 1);
  
                        if (AnotherNameJoin.equals(""))
                            newRow.add(AnotherName2 + "_" + deviceResourceBean.getNodename());//(String)deviceGroupPara.get(0));
                        else
                            newRow.add(AnotherName2 + "_" + AnotherNameJoin + "_" + deviceResourceBean.getNodename());
                        //newRow.add(deviceResourceBean.getNodename());
                        newRow.add(AnotherName2);
                        newRow.add(deviceResourceBean.getSerialno());

                        RecordChannelTableModel.addRow(newRow);//和下面的语句效果实际证明是同样的。
//                deviceManagedTableModel.getDataVector().add(newRow);
                }
    

            }
            RecordChannelTableModel.fireTableDataChanged();
            //将录像通道是否正确读出信息，用颜色标识出来。如果开始时读出录像通道设置信息错误，字体用红色表示。
            jTableRecordChannel.getColumn(tableTitle[1]).setCellRenderer(new ColorTableRender());
            jTableRecordChannel.getColumn(tableTitle[2]).setCellRenderer(new ColorTableRender());
            
            jTableRecordChannel.repaint();

        }catch(Exception e){
            TxtLogger.append(this.sFileName, "fillIntoTableRecordChannel()","系统在刷新录像通道列表过程中，出现错误" + 
                            "\r\n                       Exception:" + e.toString());   
        }
    }
    
    /**
        *函数:      refreshTableRecordChannel
        *函数描述:  从数据库中提取所有的管理设备到JTable中
    */
    private void refreshTableRecordChannel(String AnotherName){
        try {
            //如果设备名和通道号和上次点击一样，则不做任何操作。
                if (AnotherName.equals(sAnotherName))  return;
                sAnotherName = AnotherName;
                fillIntoTableRecordChannel( AnotherName);

        }catch(Exception e)
        {
            TxtLogger.append(this.sFileName, "refreshTableRecordChannel()","系统在刷新录像通道列表过程中，出现错误" + 
                            "\r\n                       Exception:" + e.toString());   
        }

    }
  
    /**
        *函数:      initialListRecordParas
        *函数描述:  获得所有录像设备的录像通道参数
    */
    private void initialListRecordParas(){
        
        try{
            /*
            获取DeviceResourceBean（设备资源表中的“设备序列号”、“节点名”、“设备资源分类”、“接入设备的序列号”）-0
            对应的“设备别名-1”、“IP地址-2”等参数，及对应的的接入设备的“设备别名-3，设备资源分类名称-4（代码表中代码名称）
            */
            listRecordChannelPara = DeviceResourceBean.getDeviceResourceParaList(CommonParas.DVRType.DVRTYPE_ENCODINGDVR_NVR_CODE, CommonParas.DVRResourceType.RESTYPE_ENCODINGDVR_CHANNEL_CODE , sFileName);

            for (int i = 0;i < listRecordChannelPara.size();i++){
                ArrayList NewList = (ArrayList)listRecordChannelPara.get(i);
                DeviceResourceBean NewResourceBean = (DeviceResourceBean)NewList.get(0);
                
                String AnotherName = (String)NewList.get(1);
                NativeLong UserID = getUserID(AnotherName);//CommonParas.getUserID((String)NewList.get(1), sFileName);
                
                if(UserID.intValue() == -1){
                    NewList.add(null);//-5
                    continue;
                }
                int Channel = CommonParas.getChannel(NewResourceBean.getNodename());

                HCNetSDK.NET_DVR_RECORD_V30 m_struRemoteRecCfg = new HCNetSDK.NET_DVR_RECORD_V30();
                
                //读取设备通道录像参数
                boolean getDVRConfigSuc = getStruRemoteRecCfg( m_struRemoteRecCfg,  UserID,  Channel);

                if (getDVRConfigSuc)
                    NewList.add(m_struRemoteRecCfg);//-5
                else 
                    NewList.add(null);//-5

            }
            
        }catch(Exception e){
            TxtLogger.append(this.sFileName, "initialListRecordParas()","系统在获得获得所有录像设备的录像通道参数过程中，出现错误" + 
                            "\r\n                       Exception:" + e.toString());   
        }
    }
    
    /**
        *函数:      getUserID
        *函数描述:  获得设备的登录ID
        * @param AnotherName   设备别名
        * @return NativeLong 设备的登录ID
    */
    private NativeLong getUserID(String AnotherName){
        NativeLong UserID = bufferUserIDs.get(AnotherName);
        if (UserID == null) {
            UserID =  CommonParas.getUserID(AnotherName, sFileName);
            bufferUserIDs.put(AnotherName, UserID);
        }
        return UserID;
    }
    
    /**
        *函数:      getStruRemoteRecCfg
        *函数描述:  获得单个设备通道的录像参数结构
        * @param m_struRemoteRecCfg   HCNetSDK.NET_DVR_RECORD_V30录像计划
        * @param UserID   设备登录ID
        * @param Channel  设备通道，包括IP通道
        * @return boolean false－获取参数失败，true－成功获取录像计划参数 
    */
    private boolean getStruRemoteRecCfg(HCNetSDK.NET_DVR_RECORD_V30 m_struRemoteRecCfg, NativeLong UserID, int Channel){
        try{
            //读取设备通道录像参数
            IntByReference ibrBytesReturned = new IntByReference(0);//获取录像参数
            m_struRemoteRecCfg.write();
            Pointer lpPicConfig = m_struRemoteRecCfg.getPointer();
            boolean getDVRConfigSuc = CommonParas.hCNetSDK.NET_DVR_GetDVRConfig(UserID, HCNetSDK.NET_DVR_GET_RECORDCFG_V30,
                new NativeLong(Channel), lpPicConfig, m_struRemoteRecCfg.size(), ibrBytesReturned);
            m_struRemoteRecCfg.read();

            return getDVRConfigSuc;
        }catch(Exception e){
            TxtLogger.append(this.sFileName, "getStruRemoteRecCfg()","系统在获得单个设备通道的录像参数结构过程中，出现错误" + 
                            "\r\n                       Exception:" + e.toString());   
        }
        return false;
    }

    
    /**
	 * 函数:      setTableColWidth
         * 函数描述:  设置表格特殊列的宽度
    */
    private void setTableColWidth(){
        
        TableColumnModel tcmRecordChannel = jTableRecordChannel.getColumnModel();
        tcmRecordChannel.getColumn(0).setMinWidth(60);
        tcmRecordChannel.getColumn(0).setMaxWidth(60);
        tcmRecordChannel.getColumn(0).setPreferredWidth(60);
        
        tcmRecordChannel.getColumn(1).setMinWidth(240);
        //tcmRecordChannel.getColumn(1).setMaxWidth(480);
        tcmRecordChannel.getColumn(1).setWidth(240);
        
        tcmRecordChannel.getColumn(2).setMinWidth(120);
        //tcmRecordChannel.getColumn(2).setMaxWidth(120);
        tcmRecordChannel.getColumn(2).setWidth(120);
        tcmRecordChannel.getColumn(3).setMinWidth(0);
        tcmRecordChannel.getColumn(3).setMaxWidth(0);
        tcmRecordChannel.getColumn(3).setWidth(0);

    }
    
    /**
        * 函数:      modifyLocales
        * 函数描述:  根据系统语言设置窗口的控件信息和消息文本
    */
    private void modifyLocales(){
        
        if (CommonParas.SysParas.ifChinese) return;//如果是中文，则不做任何操作

        
        MyLocales Locales = CommonParas.SysParas.sysLocales;
        
        //信息显示
        sTitle                  = Locales.getString("ClassStrings", "JDialogRecordSchedule.sTitle");  //录像存储快速设置
        sTableTitle             = Locales.getString("ClassStrings", "JDialogRecordSchedule.sTableTitle");  //设置,录像通道,设备名,序列号
        sRecordParaSetup        = Locales.getString("ClassStrings", "JDialogRecordSchedule.sRecordParaSetup");  //设置录像参数
        sRecordParaSetupSucc    = Locales.getString("ClassStrings", "JDialogRecordSchedule.sRecordParaSetupSucc");  //已设置该录像通道为录像状态
        sRecordParaSetupSuccNot = Locales.getString("ClassStrings", "JDialogRecordSchedule.sRecordParaSetupSuccNot");  //已设置该录像通道为不录像状态
        sRecordParaSetup_Fail   = Locales.getString("ClassStrings", "JDialogRecordSchedule.sRecordParaSetup_Fail");  //设置录像参数失败
        sDevice                 = Locales.getString("ClassStrings", "JDialogRecordSchedule.sDevice");  //设备
        sRefreshChannelInfo     = Locales.getString("ClassStrings", "JDialogRecordSchedule.sRefreshChannelInfo");  //刷新设备录像通道状态信息

        tableTitle = sTableTitle.split(",");
        this.setTitle(sTitle);
 
        //标签和按钮显示
        jLabelTitle.setText(sTitle);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonExit;
    private javax.swing.JLabel jLabelTitle;
    private javax.swing.JPanel jPanelContainer;
    private javax.swing.JPanel jPanelFirst;
    private javax.swing.JScrollPane jScrollPaneDevice;
    private javax.swing.JScrollPane jScrollPaneRecord;
    private javax.swing.JSplitPane jSplitPaneRecordChannel;
    private javax.swing.JTable jTableRecordChannel;
    private javax.swing.JTree jTreeDevice;
    // End of variables declaration//GEN-END:variables

    private String sTitle = "录像存储快速设置";
    private String sTableTitle = "设置,录像通道,设备名,序列号";
    private String sRecordParaSetup = "设置录像参数";
    private String sRecordParaSetupSucc = "已设置该录像通道为录像状态";
    private String sRecordParaSetupSuccNot = "已设置该录像通道为不录像状态";
    private String sRecordParaSetup_Fail = "设置录像参数失败";
    private String sDevice = "设备";
    private String sRefreshChannelInfo = "刷新设备录像通道状态信息";

    private class ColorTableRender extends DefaultTableCellRenderer 
    {

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {
            // TODO Auto-generated method stub
            Component comp = super.getTableCellRendererComponent(table, value, isSelected,hasFocus, row, column);
            try{
                int Row_Model= table.convertRowIndexToModel(row);//将视图中的行索引转化为数据模型中的行索引
                ArrayList NewList = (ArrayList)listRecordChannelPara.get(Row_Model);
                HCNetSDK.NET_DVR_RECORD_V30 m_struRemoteRecCfg = (HCNetSDK.NET_DVR_RECORD_V30)NewList.get(5);

                if (m_struRemoteRecCfg == null) comp.setForeground(Color.RED);
            }catch(Exception e){
                 
            }
            return comp;
        }
    }
    
    /**
        *类:      RefreshRecordChannelParasWorker
        *类描述:  刷新设备录像通道状态并行线程类
    */
    private class RefreshRecordChannelParasWorker extends SwingWorker {

        RefreshRecordChannelParasWorker(){
            bDeviceRefreshing = true;//是否正在刷新设备状态
            CommonParas.showProgressWindow(this);
        }
        @Override
        protected Object doInBackground() throws Exception {
            CommonParas.setPorgressInfo(sRefreshChannelInfo);//"刷新设备录像通道状态信息"
            initialListRecordParas();
            fillIntoTableRecordChannel("");//添加全部录像通道
            return null;
        }
        
        @Override
        protected void done(){
            bDeviceRefreshing = false;//是否正在刷新设备状态
            CommonParas.closeProgressWindow();
        }
    }
}

